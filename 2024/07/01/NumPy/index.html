<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>NumPy | 久书的Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  
  
    <link rel="alternate" href="/atom.xml" title="久书的Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="/localshare/css/share.css">

  
  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">久书的Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/."><i class="fa fa-home"></i> Home</a>
        
          <a class="main-nav-link" href="/archives/"><i class="fa fa-archive"></i> Archive</a>
        
          <a class="main-nav-link" href="/about/"><i class="fa fa-user"></i> About</a>
        
          <a class="main-nav-link" href="/atom.xml"><i class="fa fa-rss"></i> RSS</a>
        
      </nav>
    </div>
    <div id="search-form">
      <div id="result-mask" class="hide"></div>
      <label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label>
      <div id="result-wrap" class="hide">
        <div id="search-result"></div>
      </div>
      <div class="hide">
        <template id="search-tpl">
          <div class="item">
            <a href="/{path}" title="{title}">
              <div class="title">{title}</div>
              <div class="time">{date}</div>
              <div class="tags">{tags}</div>
            </a>
          </div>
        </template>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-NumPy" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      NumPy
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2024-07-01T08:18:24.000Z" itemprop="datePublished">2024年07月01日</time>
</span>
      
      
        <span class="article-views">
  <i class="fa fa-views"></i>
  <i id="busuanzi_container_page_pv">
      <i id="busuanzi_value_page_pv"></i>
  </i>
</span>

      
      
<a href="/2024/07/01/NumPy/#comments" class="article-comment-link">
  
    
      <span class="post-comments-count valine-comment-count" data-xid="/2024/07/01/NumPy/" itemprop="commentCount"></span>
    
    
    
    
    
  
  <i class="fa fa-commt"></i>
  Guestbook
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>NumPy是一个开源的Python库，专为数值计算设计。它为高性能的多维数组对象提供了支持，并包含了大量的操作这些数组的函数和工具。由于其功能强大、使用简便，NumPy成为了科学计算、数据分析、机器学习等领域中使用Python的基石之一。</p>
<h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><ol>
<li><strong>多维数组对象（ndarray）</strong>：NumPy的核心是多维数组对象，也即ndarray。这个对象是一个快速、灵活的大数据容器，允许你进行向量化的数学运算。</li>
<li><strong>广播功能</strong>：在进行数组运算时，NumPy能够处理不同形状的数组，使得数组间的运算变得简单、直观。</li>
<li><strong>高效的数学函数库</strong>：提供了大量的数学函数，包括线性代数运算、傅里叶变换和统计操作等，以便对这些多维数组进行高效操作。</li>
<li><strong>集成C&#x2F;C++和Fortran代码</strong>：NumPy允许你将C&#x2F;C++和Fortran代码直接集成到Python环境中，这使得在算法上可以达到极高的计算效率。</li>
<li><strong>灵活的内存映射</strong>：支持让数据直接在硬盘和内存中映射存储，这对处理大量数据尤其有用。</li>
</ol>
<h3 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h3><ul>
<li><strong>科学计算</strong>：NumPy提供了大量的数学函数库，使其成为科学计算中不可或缺的工具，广泛应用于物理、天文、工程等领域。</li>
<li><strong>数据分析</strong>：在数据预处理、转换和操作等方面，NumPy提供了简便、快速的方法，是进行数据分析不可分割的一部分。</li>
<li><strong>机器学习</strong>：作为机器学习中进行数值计算和数据处理的基础库，NumPy为各种机器学习框架提供了底层支持。</li>
<li><strong>图像处理与计算机视觉</strong>：NumPy的数组操作能够方便地用于图像上的各种变换和处理。</li>
</ul>
<h2 id="ndarray：多维数组对象"><a href="#ndarray：多维数组对象" class="headerlink" title="ndarray：多维数组对象"></a>ndarray：多维数组对象</h2><p>NumPy最重要的一个特点就是其N维数组对象（即ndarray），该对象是一个快速而灵活的大数据集容器。你可以利用这种数组对整块数据执行一些数学运算，其语法跟标量元素之间的运算一样。</p>
<p>ndarray是一个通用的同构数据多维容器，也就是说，其中的所有元素必须是相同类型的。每个数组都有一个shape（一个表示各维度大小的元组）和一个dtype（一个用于说明数组数据类型的对象）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = np.random.randn(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">data1 = data * <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(data1)</span><br><span class="line">data1 += data1</span><br><span class="line"><span class="built_in">print</span>(data1)</span><br><span class="line"><span class="built_in">print</span>(data.shape, data.dtype)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="创建ndarry对象"><a href="#创建ndarry对象" class="headerlink" title="创建ndarry对象"></a>创建ndarry对象</h3><p>创建数组最简单的办法就是使用array函数。它接受一切序列型的对象（包括其他数组），然后产生一个新的含有传入数据的NumPy数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个列表转换</span></span><br><span class="line">arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8.7</span>]</span><br><span class="line">nparr1 = np.array(arr1)</span><br><span class="line"><span class="built_in">print</span>(nparr1, nparr1.shape, nparr1.dtype)</span><br><span class="line"><span class="comment"># 嵌套序列（比如由一组等长列表组成的列表）将会被转换为一个多维数组：</span></span><br><span class="line">arr2 = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">nparr2 = np.array(arr2)</span><br><span class="line"><span class="built_in">print</span>(nparr2, <span class="string">&#x27;\n&#x27;</span>, nparr2.shape, nparr2.dtype)</span><br></pre></td></tr></table></figure>

<p>除非特别说明（稍后将会详细介绍），np.array会尝试为新建的这个数组推断出一个较为合适的数据类型。数据类型保存在一个特殊的dtype对象中。</p>
<p>除np.array之外，还有一些函数也可以新建数组。比如，zeros和ones分别可以创建指定长度或形状的全0或全1数组。empty可以创建一个没有任何具体值的数组。要用这些方法创建多维数组，只需传入一个表示形状的元组即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nparr3 = np.zeros((<span class="number">3</span>, <span class="number">3</span>), numpy.int32)</span><br><span class="line"><span class="built_in">print</span>(nparr3)</span><br><span class="line"><span class="built_in">print</span>(np.empty((<span class="number">3</span>, <span class="number">3</span>)))</span><br><span class="line"><span class="built_in">print</span>(np.ones((<span class="number">3</span>, <span class="number">3</span>)))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：认为np.empty会返回全0数组的想法是不安全的。很多情况下（如前所示），它返回的都是一些未初始化的垃圾值(随机值)。</p>
</blockquote>
<p>arange是Python内置函数range的数组版：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.arange(<span class="number">20</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]</span></span><br></pre></td></tr></table></figure>

<p>下表列出了一些数组创建函数。由于NumPy关注的是数值计算，因此，如果没有特别指定，数据类型基本都是float64（浮点数）。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>array</td>
<td>将输入数据转化为narray，默认直接复制输入数据</td>
</tr>
<tr>
<td>asarray</td>
<td>将输入数据转化为ndarray，如果输入数据是ndarray就不进行复制</td>
</tr>
<tr>
<td>arrange</td>
<td>返回在指定区间内的均匀分布的值</td>
</tr>
<tr>
<td>zeros</td>
<td>返回具有指定shape和类型的新数组，填充元素0</td>
</tr>
<tr>
<td>zeros_like</td>
<td>返回和输入参数参数具有相同shape和类型的新数组，填充元素0</td>
</tr>
<tr>
<td>ones</td>
<td>返回指定形状和类型的数组、填充元素‘1’.</td>
</tr>
<tr>
<td>ones_like</td>
<td>返回和给定数组具有相同形状和类型的数组</td>
</tr>
<tr>
<td>identity</td>
<td>返回主对角线上都是1的数组</td>
</tr>
<tr>
<td>empty</td>
<td>返回指定形状和类型的数组，并未初始化条目</td>
</tr>
<tr>
<td>empty_like</td>
<td>返回指定数组形状和类型的数组，并未初始化条目</td>
</tr>
</tbody></table>
<h3 id="ndarray数据类型"><a href="#ndarray数据类型" class="headerlink" title="ndarray数据类型"></a>ndarray数据类型</h3><p>numpy 支持的数据类型比 Python 内置的类型要多很多，基本上可以和 C 语言的数据类型对应上，其中部分类型对应为 Python 内置的类型。下表列举了常用 NumPy 基本类型。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bool_</td>
<td>布尔型数据类型（True 或者 False）</td>
</tr>
<tr>
<td>int_</td>
<td>默认的整数类型（类似于 C 语言中的 long，int32 或 int64）</td>
</tr>
<tr>
<td>intc</td>
<td>与 C 的 int 类型一样，一般是 int32 或 int 64</td>
</tr>
<tr>
<td>intp</td>
<td>用于索引的整数类型（类似于 C 的 ssize_t，一般情况下仍然是 int32 或 int64）</td>
</tr>
<tr>
<td>int8</td>
<td>字节（-128 to 127）</td>
</tr>
<tr>
<td>int16</td>
<td>整数（-32768 to 32767）</td>
</tr>
<tr>
<td>int32</td>
<td>整数（-2147483648 to 2147483647）</td>
</tr>
<tr>
<td>int64</td>
<td>整数（-9223372036854775808 to 9223372036854775807）</td>
</tr>
<tr>
<td>uint8</td>
<td>无符号整数（0 to 255）</td>
</tr>
<tr>
<td>uint16</td>
<td>无符号整数（0 to 65535）</td>
</tr>
<tr>
<td>uint32</td>
<td>无符号整数（0 to 4294967295）</td>
</tr>
<tr>
<td>uint64</td>
<td>无符号整数（0 to 18446744073709551615）</td>
</tr>
<tr>
<td>float_</td>
<td>float64 类型的简写</td>
</tr>
<tr>
<td>float16</td>
<td>半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</td>
</tr>
<tr>
<td>float32</td>
<td>单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</td>
</tr>
<tr>
<td>float64</td>
<td>双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</td>
</tr>
<tr>
<td>complex_</td>
<td>complex128 类型的简写，即 128 位复数</td>
</tr>
<tr>
<td>complex64</td>
<td>复数，表示双 32 位浮点数（实数部分和虚数部分）</td>
</tr>
<tr>
<td>complex128</td>
<td>复数，表示双 64 位浮点数（实数部分和虚数部分）</td>
</tr>
<tr>
<td>object</td>
<td>python对象类型</td>
</tr>
<tr>
<td>string_</td>
<td>固定长度的字符串类型</td>
</tr>
<tr>
<td>unicode_</td>
<td>固定长度的unicode类型</td>
</tr>
</tbody></table>
<p>可以通过ndarray的astype方法明确地将一个数组从一个dtype转换成另一个dtype：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用astype改变数据类型</span></span><br><span class="line">arr2 = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">nparr2 = np.array(arr2)</span><br><span class="line">asarr = nparr2.astype(np.float32)</span><br><span class="line"><span class="built_in">print</span>(asarr)</span><br><span class="line"><span class="built_in">print</span>(asarr.dtype)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果将浮点数转换成整数，则小数部分将会被截取删除</p>
</blockquote>
<p><strong>注意：</strong>调用astype总会创建一个新的数组（一个数据的备份），即使新的dtype与旧的dtype相同。</p>
<h3 id="NumPy数组的运算"><a href="#NumPy数组的运算" class="headerlink" title="NumPy数组的运算"></a>NumPy数组的运算</h3><p>数组很重要，因为它使你不用编写循环即可对数据执行批量运算。NumPy用户称其为矢量化（vectorization）。大小相等的数组之间的任何算术运算都会将运算应用到元素级：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">arr = [[<span class="number">1.</span>,<span class="number">2.</span>, <span class="number">3.</span>], [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>], [<span class="number">7.</span>, <span class="number">8.</span>, <span class="number">9.</span>]]</span><br><span class="line">arr1 = np.array(arr)</span><br><span class="line"><span class="built_in">print</span>(arr1)</span><br><span class="line"><span class="built_in">print</span>(arr1 * arr1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [[1. 2. 3.]</span></span><br><span class="line"><span class="comment">#  [4. 5. 6.]</span></span><br><span class="line"><span class="comment"># [7. 8. 9.]]</span></span><br><span class="line"><span class="comment"># [[ 1.  4.  9.]</span></span><br><span class="line"><span class="comment">#  [16. 25. 36.]</span></span><br><span class="line"><span class="comment"># [49. 64. 81.]]</span></span><br></pre></td></tr></table></figure>

<p>数组与标量的算术运算会将标量值传播到各个元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(arr1 + <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> / arr1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [[ 3.  4.  5.]</span></span><br><span class="line"><span class="comment">#  [ 6.  7.  8.]</span></span><br><span class="line"><span class="comment"># [ 9. 10. 11.]]</span></span><br><span class="line"><span class="comment"># [[1.         0.5        0.33333333]</span></span><br><span class="line"><span class="comment">#  [0.25       0.2        0.16666667]</span></span><br><span class="line"><span class="comment"># [0.14285714 0.125      0.11111111]]</span></span><br></pre></td></tr></table></figure>

<p>大小相同的数组之间的比较会生成布尔值数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = [[<span class="number">1.</span>,<span class="number">2.3</span>, <span class="number">3.55</span>], [<span class="number">3.1</span>, <span class="number">3.78</span>, <span class="number">6.1</span>], [<span class="number">5.986</span>, <span class="number">8.1</span>, <span class="number">2.43</span>]]</span><br><span class="line">arr2 = np.array(arr)</span><br><span class="line"><span class="built_in">print</span>(arr2 &gt; arr1)</span><br><span class="line"><span class="comment"># [[False  True  True]</span></span><br><span class="line"><span class="comment">#  [False False  True]</span></span><br><span class="line"><span class="comment"># [False  True False]]</span></span><br></pre></td></tr></table></figure>

<h3 id="基本的索引和切片"><a href="#基本的索引和切片" class="headerlink" title="基本的索引和切片"></a>基本的索引和切片</h3><p>NumPy数组的索引是一个内容丰富的主题，因为选取数据子集或单个元素的方式有很多。一维数组很简单。从表面上看，它们跟Python列表的功能差不多：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(arr[<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(arr[<span class="number">2</span>: <span class="number">5</span>])</span><br><span class="line">arr[<span class="number">2</span>: <span class="number">5</span>] = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># [2 3 4]</span></span><br><span class="line"><span class="comment"># [ 0  1 20 20 20  5  6  7  8  9]</span></span><br></pre></td></tr></table></figure>

<p>如上所示，当你将一个标量值赋值给一个切片时（如arr[5:8]&#x3D;12），该值会自动传播（也就说后面将会讲到的“广播”）到整个选区。跟列表最重要的区别在于，数组切片是原始数组的视图。这意味着数据不会被复制，视图上的任何修改都会直接反映到源数组上。</p>
<p>先创建一个arr的切片，当我修改arr_slice中的值，变动也会体现在原始数组arr中，切片[ : ]会给数组中的所有值赋值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建arr切片，得到arr_slice视图</span></span><br><span class="line">arr_slice = arr[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(arr_slice)</span><br><span class="line"><span class="comment"># 修改arr_slice试图，arr也会随着修改</span></span><br><span class="line">arr_slice[<span class="number">0</span>: <span class="number">2</span>] = <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(arr_slice)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line">arr[:] = <span class="number">62</span></span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="comment"># [20 20 20]</span></span><br><span class="line"><span class="comment"># [1000 1000   20]</span></span><br><span class="line"><span class="comment"># [   0    1 1000 1000   20    5    6    7    8    9]</span></span><br><span class="line"><span class="comment"># [62 62 62 62 62 62 62 62 62 62]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果想要得到的是ndarray切片的一份副本而非视图，就需要明确地进行复制操作，例如<code>arr[5:8].copy()</code>。</p>
</blockquote>
<p>对于高维度数组，能做的事情更多。在一个二维数组中，各索引位置上的元素不再是标量而是一维数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">np_arr = np.array(arr)</span><br><span class="line"><span class="built_in">print</span>(np_arr)</span><br><span class="line"><span class="built_in">print</span>(np_arr[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]</span></span><br><span class="line"><span class="comment"># [7 8 9]]</span></span><br><span class="line"><span class="comment"># [1 2 3]</span></span><br></pre></td></tr></table></figure>

<p>因此，可以对各个元素进行递归访问，但这样需要做的事情有点多。你可以传入一个以逗号隔开的索引列表来选取单个元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np_arr[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(np_arr[<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<h3 id="切片索引"><a href="#切片索引" class="headerlink" title="切片索引"></a>切片索引</h3><p>ndarray的切片语法跟Python列表这样的一维对象差不多：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(arr[<span class="number">1</span>: <span class="number">7</span>])</span><br><span class="line"><span class="comment"># [1 2 3 4 5 6]</span></span><br></pre></td></tr></table></figure>

<p>对于之前的二维数组，其切片方式稍显不同：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">np_arr = np.array(arr)</span><br><span class="line"><span class="built_in">print</span>(np_arr[<span class="number">1</span>, :<span class="number">3</span>])</span><br><span class="line"><span class="comment"># [[4 5 6]]</span></span><br></pre></td></tr></table></figure>

<p><strong>对切片表达式的赋值操作也会被扩散到整个选区</strong></p>
<h3 id="布尔型索引"><a href="#布尔型索引" class="headerlink" title="布尔型索引"></a>布尔型索引</h3><p>假设有一个用于存储数据的数组以及一个存储姓名的数组（含有重复项），假设每个名字都对应data数组中的一行，而我们想要选出对应于名字”Bob”的所有行。跟算术运算一样，数组的比较运算（如&#x3D;&#x3D;）也是矢量化的。因此，对names和字符串”Bob”的比较运算将会产生一个布尔型数组，这个布尔型数组可用于数组索引：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">names = np.array([<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>])</span><br><span class="line">data = np.random.randn(<span class="number">7</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data = \n&#x27;</span>, data)</span><br><span class="line"><span class="comment"># names和字符串&quot;Bob&quot;的比较运算将会产生一个布尔型数组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;names == \&#x27;Bob\&#x27;: \n&#x27;</span>, names == <span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line"><span class="comment"># 布尔型数组可用于数组索引</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data[names == \&#x27;Bob\&#x27;]: \n&#x27;</span>, data[names == <span class="string">&#x27;Bob&#x27;</span>])</span><br><span class="line"><span class="comment"># data =</span></span><br><span class="line"><span class="comment"># [[-2.06312192 -0.47269856 -1.92389771  0.91278498]</span></span><br><span class="line"><span class="comment">#  [-2.58358617 -0.03263164 -0.08267246 -0.69128665]</span></span><br><span class="line"><span class="comment">#  [ 0.52652726 -0.48812597  0.09661174  1.18237505]</span></span><br><span class="line"><span class="comment"># [-0.25987874 -1.07423519  0.52132457  0.04803203]</span></span><br><span class="line"><span class="comment"># [-0.16248655 -0.98312311 -0.35371249 -0.26627604]</span></span><br><span class="line"><span class="comment"># [-0.75293904 -1.11616931  0.17385702 -0.55176087]</span></span><br><span class="line"><span class="comment"># [ 0.71264865 -0.25099606  0.36425637  0.41166286]]</span></span><br><span class="line"><span class="comment"># names == &#x27;Bob&#x27;:</span></span><br><span class="line"><span class="comment"># [ True False False  True False False False]</span></span><br><span class="line"><span class="comment"># data[names == &#x27;Bob&#x27;]:</span></span><br><span class="line"><span class="comment"># [[-2.06312192 -0.47269856 -1.92389771  0.91278498]</span></span><br><span class="line"><span class="comment">#  [-0.25987874 -1.07423519  0.52132457  0.04803203]]</span></span><br></pre></td></tr></table></figure>

<p>布尔型数组的长度必须跟被索引的轴长度一致。此外，还可以将布尔型数组跟切片、整数混合使用。</p>
<blockquote>
<p>注意：如果布尔型数组的长度不对，布尔型选择就会出错，因此一定要小心。</p>
</blockquote>
<p>要选择除”Bob”以外的其他值，既可以使用不等于符号（!&#x3D;），也可以通过~对条件进行否定：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data[names != \&#x27;Bob\&#x27;]: \n&#x27;</span>, data[names != <span class="string">&#x27;Bob&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data[names != \&#x27;Bob\&#x27;]: \n&#x27;</span>, data[~(names == <span class="string">&#x27;Bob&#x27;</span>)])</span><br><span class="line"><span class="comment"># data[names != &#x27;Bob&#x27;]:</span></span><br><span class="line"><span class="comment"># [[ 0.16468039 -1.03862911 -1.17996131  0.05199666]</span></span><br><span class="line"><span class="comment">#  [-1.43097098 -0.0990478   1.03564949  0.95265985]</span></span><br><span class="line"><span class="comment"># [-1.46271439 -2.02827434 -1.33157357 -1.14378972]</span></span><br><span class="line"><span class="comment"># [-0.66219836 -0.40306316 -0.62727381 -0.21806554]</span></span><br><span class="line"><span class="comment"># [ 0.40196128  1.11803113 -0.51840519 -1.18794547]]</span></span><br><span class="line"><span class="comment"># data[names != &#x27;Bob&#x27;]:</span></span><br><span class="line"><span class="comment"># [[ 0.16468039 -1.03862911 -1.17996131  0.05199666]</span></span><br><span class="line"><span class="comment">#  [-1.43097098 -0.0990478   1.03564949  0.95265985]</span></span><br><span class="line"><span class="comment"># [-1.46271439 -2.02827434 -1.33157357 -1.14378972]</span></span><br><span class="line"><span class="comment"># [-0.66219836 -0.40306316 -0.62727381 -0.21806554]</span></span><br><span class="line"><span class="comment"># [ 0.40196128  1.11803113 -0.51840519 -1.18794547]]</span></span><br></pre></td></tr></table></figure>

<p>选取这三个名字中的两个需要组合应用多个布尔条件，使用&amp;（和）、|（或）之类的布尔算术运算符即可，通过布尔型索引选取数组中的数据，将总是创建数据的副本，即使返回一模一样的数组也是如此。</p>
<blockquote>
<p>注意：Python关键字and和or在布尔型数组中无效。要使用&amp;与|。</p>
</blockquote>
<h3 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h3><p>花式索引（Fancy indexing）是一个NumPy术语，它指的是利用整数数组进行索引。对于二维数组而言第一个数组选取的是二维数组的行，第二个数组选取的是二维数组的列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">32</span>).reshape(<span class="number">8</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="built_in">print</span>(arr[[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(arr[[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>]])</span><br><span class="line"><span class="comment"># [[ 0  1  2  3]</span></span><br><span class="line"><span class="comment">#  [ 4  5  6  7]</span></span><br><span class="line"><span class="comment"># [ 8  9 10 11]</span></span><br><span class="line"><span class="comment"># [12 13 14 15]</span></span><br><span class="line"><span class="comment"># [16 17 18 19]</span></span><br><span class="line"><span class="comment"># [20 21 22 23]</span></span><br><span class="line"><span class="comment"># [24 25 26 27]</span></span><br><span class="line"><span class="comment"># [28 29 30 31]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [[ 4  5  6  7]</span></span><br><span class="line"><span class="comment">#  [12 13 14 15]</span></span><br><span class="line"><span class="comment"># [16 17 18 19]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [ 4 15 18]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用负数索引将会从末尾开始选取行。</p>
</blockquote>
<h2 id="数组转置和轴对换"><a href="#数组转置和轴对换" class="headerlink" title="数组转置和轴对换"></a>数组转置和轴对换</h2><p>转置是重塑的一种特殊形式，它返回的是源数据的视图（不会进行任何复制操作）。数组不仅有transpose方法，还有一个特殊的T属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">15</span>).reshape(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="built_in">print</span>(arr.T)</span><br><span class="line"><span class="comment"># [[ 0  1  2  3  4]</span></span><br><span class="line"><span class="comment">#  [ 5  6  7  8  9]</span></span><br><span class="line"><span class="comment"># [10 11 12 13 14]]</span></span><br><span class="line"><span class="comment"># [[ 0  5 10]</span></span><br><span class="line"><span class="comment">#  [ 1  6 11]</span></span><br><span class="line"><span class="comment"># [ 2  7 12]</span></span><br><span class="line"><span class="comment"># [ 3  8 13]</span></span><br><span class="line"><span class="comment"># [ 4  9 14]]</span></span><br></pre></td></tr></table></figure>

<p>在进行矩阵计算时，经常需要用到该操作，比如利用np.dot计算矩阵内积：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.dot(arr, arr.T))</span><br><span class="line"><span class="comment"># [[ 30  80 130]</span></span><br><span class="line"><span class="comment">#  [ 80 255 430]</span></span><br><span class="line"><span class="comment"># [130 430 730]]</span></span><br></pre></td></tr></table></figure>

<p>对于高维数组，transpose需要得到一个由轴编号组成的元组才能对这些轴进行转置（比较费脑子）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">16</span>).reshape((<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="built_in">print</span>(arr.transpose(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># [[ 0  1  2  3  4]</span></span><br><span class="line"><span class="comment">#  [ 5  6  7  8  9]</span></span><br><span class="line"><span class="comment"># [10 11 12 13 14]]</span></span><br><span class="line"><span class="comment"># [[ 0  5 10]</span></span><br><span class="line"><span class="comment">#  [ 1  6 11]</span></span><br><span class="line"><span class="comment"># [ 2  7 12]</span></span><br><span class="line"><span class="comment"># [ 3  8 13]</span></span><br><span class="line"><span class="comment"># [ 4  9 14]]</span></span><br><span class="line"><span class="comment"># [[ 30  80 130]</span></span><br><span class="line"><span class="comment">#  [ 80 255 430]</span></span><br><span class="line"><span class="comment"># [130 430 730]]</span></span><br><span class="line"><span class="comment"># [[[ 0  1  2  3]</span></span><br><span class="line"><span class="comment">#   [ 4  5  6  7]]</span></span><br></pre></td></tr></table></figure>

<h2 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h2><p>通用函数（即ufunc）是一种对ndarray中的数据执行元素级运算的函数。你可以将其看做简单函数（接受一个或多个标量值，并产生一个或多个标量值）的矢量化包装器。</p>
<p>许多ufunc都是简单的元素级变体，如sqrt和exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(np.sqrt(arr))</span><br><span class="line"><span class="built_in">print</span>(np.exp(arr))	</span><br><span class="line"><span class="comment"># [0.         1.         1.41421356 1.73205081 2.         2.23606798</span></span><br><span class="line"><span class="comment">#  2.44948974 2.64575131 2.82842712 3.        ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [1.00000000e+00 2.71828183e+00 7.38905610e+00 2.00855369e+01</span></span><br><span class="line"><span class="comment">#  5.45981500e+01 1.48413159e+02 4.03428793e+02 1.09663316e+03</span></span><br><span class="line"><span class="comment">#  2.98095799e+03 8.10308393e+03]</span></span><br></pre></td></tr></table></figure>

<p>这些都是一元（unary）ufunc。另外一些（如add或maximum）接受2个数组（因此也叫二元（binary）ufunc），并返回一个结果数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.random.randn(<span class="number">10</span>)</span><br><span class="line">arr2 = np.random.randn(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(arr1)</span><br><span class="line"><span class="built_in">print</span>(arr2)</span><br><span class="line">add_arr = np.add(arr1, arr2)</span><br><span class="line"><span class="built_in">print</span>(add_arr)</span><br><span class="line"><span class="built_in">print</span>(np.sqrt(add_arr))</span><br><span class="line">max_arr = np.maximum(arr1, arr2)</span><br><span class="line"><span class="built_in">print</span>(max_arr)</span><br><span class="line"><span class="comment"># [ 1.38436386 -1.15920008 -0.14072652  0.18714392 -0.02133517 -0.45635813</span></span><br><span class="line"><span class="comment">#   2.23557513  0.60269672  0.57079306 -0.30629098]</span></span><br><span class="line"><span class="comment"># [-0.70702438  0.81761517  1.1078126  -2.25015848  0.32766901 -2.14322612</span></span><br><span class="line"><span class="comment">#  -0.18305529 -0.90640026  0.30361236  0.15709559]</span></span><br><span class="line"><span class="comment"># [ 0.67733948 -0.34158491  0.96708608 -2.06301456  0.30633383 -2.59958425</span></span><br><span class="line"><span class="comment">#   2.05251984 -0.30370355  0.87440541 -0.1491954 ]</span></span><br><span class="line"><span class="comment"># [0.82300637        nan 0.98340535        nan 0.55347433        nan</span></span><br><span class="line"><span class="comment">#  1.4326618         nan 0.93509647        nan]</span></span><br><span class="line"><span class="comment"># [ 1.38436386  0.81761517  1.1078126   0.18714392  0.32766901 -0.45635813</span></span><br><span class="line"><span class="comment">#   2.23557513  0.60269672  0.57079306  0.15709559]</span></span><br></pre></td></tr></table></figure>

<p>虽然并不常见，但有些ufunc的确可以返回多个数组。modf就是一个例子，它是Python内置函数divmod的矢量化版本，它会返回浮点数数组的小数和整数部分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.random.randn(<span class="number">10</span>) * <span class="number">10</span></span><br><span class="line">arr_float, arr_int = np.modf(arr1)</span><br><span class="line"><span class="built_in">print</span>(arr_int)</span><br><span class="line"><span class="built_in">print</span>(arr_float)</span><br><span class="line"><span class="comment"># [  1.  -1.  -3.  17.  -9.   2.  -5.   1. -22.  -1.]</span></span><br><span class="line"><span class="comment"># [ 0.47596625 -0.74938756 -0.06916514  0.11201267 -0.19124248  0.72119225</span></span><br><span class="line"><span class="comment">#   -0.2189372   0.60465544 -0.75157779 -0.83174716]</span></span><br></pre></td></tr></table></figure>

<p>常用一元二元ufunc如下表：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>abs&#x2F;fabs</td>
<td>计算整数、浮点数、复数的绝对值。对于非复数值可使用更快的fabs</td>
</tr>
<tr>
<td>sqrt</td>
<td>计算各元素的平方根</td>
</tr>
<tr>
<td>square</td>
<td>计算各元素的平方</td>
</tr>
<tr>
<td>exp</td>
<td>计算各元素的指数e^x</td>
</tr>
<tr>
<td>log&#x2F;log10&#x2F;log2&#x2F;log1p<code>(log(1+x))</code></td>
<td>对数函数</td>
</tr>
<tr>
<td>sign</td>
<td>符号函数（1：正数；0：零；-1：负数）</td>
</tr>
<tr>
<td>cell</td>
<td>计算各元素大于等于该元素最小整数（向上取整）</td>
</tr>
<tr>
<td>floor</td>
<td>计算各元素小于等于该元素最大整数（向下取整）</td>
</tr>
<tr>
<td>rint</td>
<td>将各元素四舍五入到最接近的整数，保留dtype</td>
</tr>
<tr>
<td>modf</td>
<td>将各元素整数和小数部分以两个独立数组形式返回</td>
</tr>
<tr>
<td>isnan</td>
<td>返回一个表示“哪些值是nan的”布尔型数组</td>
</tr>
<tr>
<td>isfinite&#x2F;isinf</td>
<td>返回一个哪些元素是有穷的&#x2F;无穷的布尔型数组</td>
</tr>
<tr>
<td>cos&#x2F;cosh&#x2F;sin&#x2F;sinh&#x2F;tan&#x2F;tanh</td>
<td>普通型和双曲型三角函数</td>
</tr>
<tr>
<td>arcsin&#x2F;arccos&#x2F;arctan&#x2F;arcsinh&#x2F;arccosh&#x2F;arctanh</td>
<td>反三角函数</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td>将数组中对应的元素相加</td>
</tr>
<tr>
<td>subtract</td>
<td>冲第一个数组中减去第二个数组中的元素</td>
</tr>
<tr>
<td>multiply</td>
<td>数组元素相乘</td>
</tr>
<tr>
<td>divide&#x2F;floor_divide</td>
<td>除法&#x2F;除法取整</td>
</tr>
<tr>
<td>power</td>
<td>对第一个数组的A元素，根据第二个数组的B元素，计算A^B</td>
</tr>
<tr>
<td>maximum&#x2F;fmax</td>
<td>元素级的最大值计算，fmax将忽略NaN</td>
</tr>
<tr>
<td>minimum&#x2F;fmin</td>
<td>元素级的最小值计算，fmin将忽略NaN</td>
</tr>
<tr>
<td>mod</td>
<td>元素级的球模计算</td>
</tr>
<tr>
<td>copysign</td>
<td>将第二个数组中的值的符号复制给第一个数组中的值</td>
</tr>
</tbody></table>
<h2 id="利用数组处理数据"><a href="#利用数组处理数据" class="headerlink" title="利用数组处理数据"></a>利用数组处理数据</h2><p>NumPy数组使你可以将许多种数据处理任务表述为简洁的数组表达式（否则需要编写循环）。用数组表达式代替循环的做法，通常被称为矢量化。一般来说，矢量化数组运算要比等价的纯Python方式快上一两个数量级（甚至更多），尤其是各种数值计算。</p>
<h3 id="将条件逻辑表示为数组运算"><a href="#将条件逻辑表示为数组运算" class="headerlink" title="将条件逻辑表示为数组运算"></a>将条件逻辑表示为数组运算</h3><p><code>numpy.where</code>函数是三元表达式<code>x if condition else y</code>的矢量化版本。</p>
<p>假设想要根据cond中的值选取xarr和yarr的值：当cond中的值为True时，选取xarr的值，否则从yarr中选取。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">xarr = np.array([<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">1.5</span>])</span><br><span class="line">yarr = np.array([<span class="number">2.1</span>, <span class="number">2.2</span>, <span class="number">2.3</span>, <span class="number">2.4</span>, <span class="number">2.5</span>])</span><br><span class="line">cond = np.array([<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    where(condition, [x, y], /):</span></span><br><span class="line"><span class="string">        根据condition返回,x/y的元素</span></span><br><span class="line"><span class="string">    当仅提供 &#x27;condition&#x27; 时，此函数是 &#x27;&#x27;np.asarray（condition）.nonzero（）&#x27;&#x27; 的简写。</span></span><br><span class="line"><span class="string">    直接使用“nonzero”应该是首选，因为它对于子类的行为是正确的。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">zarr = np.where(cond, xarr, yarr)</span><br><span class="line"><span class="built_in">print</span>(zarr)</span><br></pre></td></tr></table></figure>

<p><code>np.where</code>第二个和第三个参数不必是数组，它们都可以是标量值。在数据分析工作中，<code>where</code>通常用于根据另一个数组而产生一个新的数组。假设有一个由随机数据组成的矩阵，将所有正值替换为<code>1</code>将所有负值替换为<code>－1</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="built_in">print</span>(np.where(arr &gt; <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>))</span><br><span class="line"><span class="comment"># [[ 1.07412227 -0.89988959 -1.42862674 -0.48433742]</span></span><br><span class="line"><span class="comment">#  [ 0.85388065 -1.15168922 -2.2994721   1.17801869]</span></span><br><span class="line"><span class="comment"># [-0.02056903  0.01658992 -0.66251106  0.73234217]</span></span><br><span class="line"><span class="comment"># [-0.68449445 -1.40815878  1.20124381 -0.63892402]]</span></span><br><span class="line"><span class="comment"># [[ 1 -1 -1 -1]</span></span><br><span class="line"><span class="comment">#  [ 1 -1 -1  1]</span></span><br><span class="line"><span class="comment"># [-1  1 -1  1]</span></span><br><span class="line"><span class="comment"># [-1 -1  1 -1]]</span></span><br></pre></td></tr></table></figure>

<p>使用<code>np.where</code>，可以将标量和数组结合起来。例如，我可用常数<code>1</code>替换<code>arr</code>中所有正的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.where(arr &gt; <span class="number">0</span>, <span class="number">1</span>, arr))</span><br><span class="line"><span class="comment"># [[-0.66384462  1.          1.          1.        ]</span></span><br><span class="line"><span class="comment">#  [ 1.         -0.71134976  1.         -0.44296096]</span></span><br><span class="line"><span class="comment"># [ 1.         -0.98135017 -0.51546953 -0.47090388]</span></span><br><span class="line"><span class="comment"># [ 1.          1.          1.         -0.01663538]]</span></span><br></pre></td></tr></table></figure>

<p>传递给where的数组大小可以不相等，甚至可以是标量值。</p>
<h3 id="数学和统计方法"><a href="#数学和统计方法" class="headerlink" title="数学和统计方法"></a>数学和统计方法</h3><p>可以通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计计算。<code>sum</code>、<code>mean</code>以及标准差<code>std</code>等聚合计算（<code>aggregation，通常叫做约简（reduction）</code>）既可以当做数组的实例方法调用，也可以当做顶级<code>NumPy</code>函数使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="comment"># 计算指定轴向的算数平均值</span></span><br><span class="line">x = arr.mean()</span><br><span class="line">y = np.mean(arr)</span><br><span class="line"><span class="built_in">print</span>(x, <span class="string">&#x27;\n&#x27;</span>, y)</span><br><span class="line"><span class="built_in">print</span>(arr.<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure>

<p><code>mean</code>和<code>sum</code>这类的函数可以接受一个<code>axis</code>选项参数，用于计算该轴向上的统计值，最终结果是一个少一维的数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>, arr.mean(axis=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>, arr.<span class="built_in">sum</span>(axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<p>这里，<code>arr.mean(axis=1)</code>是“计算行的平均值”，<code>arr.sum(axis=0)</code>是“计算每列的和”。</p>
<p>其他如<code>cumsum</code>和<code>cumprod</code>之类的方法则不聚合，而是产生一个由中间结果组成的数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line">arr_sum = arr.cumsum()</span><br><span class="line"><span class="built_in">print</span>(arr_sum)</span><br><span class="line">arr1 = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(arr1)</span><br><span class="line"><span class="comment"># 返回数组元素在给定轴上的累积乘积。</span></span><br><span class="line"><span class="built_in">print</span>(arr1.cumprod(axis=<span class="number">0</span>))</span><br><span class="line"><span class="comment"># 若未指定轴向则会被压缩为一个一维数组</span></span><br><span class="line"><span class="built_in">print</span>(arr1.cumprod())	</span><br><span class="line"><span class="comment"># [0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"><span class="comment"># [ 0  1  3  6 10 15 21 28 36 45]</span></span><br><span class="line"><span class="comment"># [[0 1 2]</span></span><br><span class="line"><span class="comment">#  [3 4 5]</span></span><br><span class="line"><span class="comment"># [6 7 8]]</span></span><br><span class="line"><span class="comment"># [[ 0  1  2]</span></span><br><span class="line"><span class="comment">#  [ 0  4 10]</span></span><br><span class="line"><span class="comment"># [ 0 28 80]]</span></span><br><span class="line"><span class="comment"># [0 0 0 0 0 0 0 0 0]</span></span><br></pre></td></tr></table></figure>

<p>下表为基本数组统计方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sum</td>
<td>对数组中全部或指定轴向的元素求和。零长度的数组和为0</td>
</tr>
<tr>
<td>mean</td>
<td>对数组中全部或指定轴向的元素求算术平均值。零长度的数组的mean为NaN</td>
</tr>
<tr>
<td>std&#x2F;var</td>
<td>计算数组的标准差和方差，自由度可调（默认为n）</td>
</tr>
<tr>
<td>min&#x2F;max</td>
<td>计算数组的最小值&#x2F;最大值</td>
</tr>
<tr>
<td>argmin&#x2F;argmax</td>
<td>返回数组最小值&#x2F;最大值的索引</td>
</tr>
<tr>
<td>cumsum</td>
<td>返回所有元素的累计和</td>
</tr>
<tr>
<td>sumprod</td>
<td>返回所有元素的累计积</td>
</tr>
</tbody></table>
<h3 id="用于布尔型数组的方法"><a href="#用于布尔型数组的方法" class="headerlink" title="用于布尔型数组的方法"></a>用于布尔型数组的方法</h3><p>在上面这些方法中，布尔值会被强制转换为<code>1（True）</code>和<code>0（False）</code>。因此，<code>sum</code>经常被用来对布尔型数组中的<code>True</code>值计数，另外还有两个方法any和all，它们对布尔型数组非常有用。	<code>any</code>用于测试数组中是否存在一个或多个<code>True</code>，而<code>all</code>则检查数组中所有值是否都是<code>True</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>((arr &gt; <span class="number">0</span>).<span class="built_in">sum</span>())</span><br><span class="line">arr_bool = np.array([<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>])</span><br><span class="line"><span class="built_in">print</span>(arr_bool.<span class="built_in">all</span>())</span><br><span class="line"><span class="built_in">print</span>(arr_bool.<span class="built_in">any</span>())</span><br><span class="line"><span class="comment"># 57</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这两个方法也能用于非布尔型数组，所有非0元素将会被当做True。</p>
</blockquote>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>和<code>Python</code>内置的列表类型一样，<code>NumPy</code>数组也可以通过<code>sort</code>方法就地排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line">arr.sort()</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="comment"># [0.70480627 0.4956195  0.2680823  0.31612777 0.89898296 0.53086524]</span></span><br><span class="line"><span class="comment"># [0.2680823  0.31612777 0.4956195  0.53086524 0.70480627 0.89898296]</span></span><br></pre></td></tr></table></figure>

<p>多维数组可以在任何一个轴向上进行排序，只需将轴编号传给<code>sort</code>即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.random.randn(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(arr1)</span><br><span class="line">arr1.sort(axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(arr1)</span><br><span class="line">arr1.sort(axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(arr1)</span><br><span class="line"><span class="comment"># [[-0.57557726  0.3814267   0.91631978]</span></span><br><span class="line"><span class="comment">#  [ 0.37041056 -0.11733325 -0.82948637]</span></span><br><span class="line"><span class="comment">#  [ 0.78834361  0.46324695  0.19573421]]</span></span><br><span class="line"><span class="comment"># [[-0.57557726  0.3814267   0.91631978]</span></span><br><span class="line"><span class="comment">#  [-0.82948637 -0.11733325  0.37041056]</span></span><br><span class="line"><span class="comment"># [ 0.19573421  0.46324695  0.78834361]]</span></span><br><span class="line"><span class="comment"># [[-0.82948637 -0.11733325  0.37041056]</span></span><br><span class="line"><span class="comment">#  [-0.57557726  0.3814267   0.78834361]</span></span><br><span class="line"><span class="comment"># [ 0.19573421  0.46324695  0.91631978]]</span></span><br></pre></td></tr></table></figure>

<p>顶级方法<code>np.sort</code>返回的是数组的已排序副本，而就地排序则会修改数组本身。计算数组分位数最简单的办法是对其进行排序，然后选取特定位置的值。</p>
<h3 id="唯一化及其它的集合逻辑"><a href="#唯一化及其它的集合逻辑" class="headerlink" title="唯一化及其它的集合逻辑"></a>唯一化及其它的集合逻辑</h3><p><code>NumPy</code>提供了一些针对一维<code>ndarray</code>的基本集合运算。最常用的可能要数<code>np.unique</code>了，它用于找出数组中的唯一值并返回已排序的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = np.array([<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>])</span><br><span class="line">name = np.unique(names)</span><br><span class="line"><span class="built_in">print</span>(name, <span class="string">&#x27; dtype=&#x27;</span>, name.dtype)</span><br></pre></td></tr></table></figure>

<p>另一个函数<code>np.in1d</code>用于测试一个数组中的值在另一个数组中的成员资格，返回一个布尔型数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">values = np.array([<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">is_exist = np.in1d(values, [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(is_exist)</span><br></pre></td></tr></table></figure>

<p><code>NumPy</code>中的集合函数请参见下表</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>unique(x)</td>
<td>计算x中唯一的元素，并返回有序结果</td>
</tr>
<tr>
<td>intersect1d(x,y)</td>
<td>计算x和y的公共元素，并返回有序结果</td>
</tr>
<tr>
<td>union1d(x,y)</td>
<td>计算x和y的并集，并返回有序结果</td>
</tr>
<tr>
<td>in1d(x,y)</td>
<td>计算得到x中的元素是否包含在y中的布尔型数组</td>
</tr>
<tr>
<td>setdiff1d(x,y)</td>
<td>集合的差，即元素在x中但不在y中</td>
</tr>
<tr>
<td>setxor1d(x,y)</td>
<td>集合的对称差，即存在于一个数组中但不同时出现在两个数组中</td>
</tr>
</tbody></table>

        
            <div id="toc-article">
                
  <div class="widget-wrap" id="toc-wrap">
    <h3 class="widget-title"><i class="fa fa-toc"></i> Contents</h3>
    <div class="widget">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NumPy"><span class="toc-text">NumPy</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F"><span class="toc-text">应用领域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ndarray%EF%BC%9A%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">ndarray：多维数组对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAndarry%E5%AF%B9%E8%B1%A1"><span class="toc-text">创建ndarry对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ndarray%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">ndarray数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NumPy%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-text">NumPy数组的运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%B4%A2%E5%BC%95%E5%92%8C%E5%88%87%E7%89%87"><span class="toc-text">基本的索引和切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%B4%A2%E5%BC%95"><span class="toc-text">切片索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%9E%8B%E7%B4%A2%E5%BC%95"><span class="toc-text">布尔型索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%B1%E5%BC%8F%E7%B4%A2%E5%BC%95"><span class="toc-text">花式索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%BD%AC%E7%BD%AE%E5%92%8C%E8%BD%B4%E5%AF%B9%E6%8D%A2"><span class="toc-text">数组转置和轴对换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">通用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE"><span class="toc-text">利用数组处理数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%9D%A1%E4%BB%B6%E9%80%BB%E8%BE%91%E8%A1%A8%E7%A4%BA%E4%B8%BA%E6%95%B0%E7%BB%84%E8%BF%90%E7%AE%97"><span class="toc-text">将条件逻辑表示为数组运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%92%8C%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-text">数学和统计方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%B8%83%E5%B0%94%E5%9E%8B%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">用于布尔型数组的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-text">排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E5%8C%96%E5%8F%8A%E5%85%B6%E5%AE%83%E7%9A%84%E9%9B%86%E5%90%88%E9%80%BB%E8%BE%91"><span class="toc-text">唯一化及其它的集合逻辑</span></a></li></ol></li></ol></li></ol>
    </div>
  </div>


            </div>
        
        
          <blockquote id="copyright">
              <p>Original link: <a href="http://example.com/2024/07/01/NumPy/">http://example.com/2024/07/01/NumPy/</a></p>
              <p>Copyright Notice: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NumPy/" rel="tag">NumPy</a></li></ul>

          
    <div class="social-share">
      <span>Share:</span>
    </div>



        </div>
      
      
        
<nav id="article-nav">
  
    <a href="/2024/06/30/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">older</strong>
      <div class="article-nav-title">
        
          hexo博客使用
        
      </div>
    </a>
  
  
    <a href="/2024/09/08/CNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">newer</strong>
      <div class="article-nav-title">
        
          CNN卷积神经网络
        
      </div>
    </a>
  
</nav>

      
      
        


  <section id="comments" class="vcomment"></section>







      
    </footer>
  </div>
</article>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-posts"></i> Recent</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/09/09/test/">test</a>
          </li>
        
          <li>
            <a href="/2024/09/08/CNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">CNN卷积神经网络</a>
          </li>
        
          <li>
            <a href="/2024/07/01/NumPy/">NumPy</a>
          </li>
        
          <li>
            <a href="/2024/06/30/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8/">hexo博客使用</a>
          </li>
        
          <li>
            <a href="/2024/06/27/%E9%9A%8F%E5%BF%83%E8%AE%B0/">随心记</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CNN/" style="font-size: 10px;">CNN</a> <a href="/tags/NumPy/" style="font-size: 10px;">NumPy</a> <a href="/tags/git-%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">git 学习</a> <a href="/tags/python%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">python学习</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">博客使用</a> <a href="/tags/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/" style="font-size: 10px;">日常积累</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">深度学习</a>
    </div>
  </div>

  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-archive"></i> Archive</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/">2024年09月</a><span class="archive-list-count">8</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CNN/" rel="tag">CNN</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NumPy/" rel="tag">NumPy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git-%E5%AD%A6%E4%B9%A0/" rel="tag">git 学习</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python%E5%AD%A6%E4%B9%A0/" rel="tag">python学习</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8/" rel="tag">博客使用</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/" rel="tag">日常积累</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">深度学习</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    

  
</aside>
        
      </div>
      <a id="totop" href="#top"></a>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <p>
        <a href="/sitemap.xml">Site Map</a>
        <span> | </span><a href="/atom.xml">Subscribe to this site</a>
        <span> | </span><a href="/about/">Contact the blogger</a>
      </p>
      
        <p>
          <i class="fa fa-visitors"></i>
          <i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>
          ，
          <i class="fa fa-views"></i>
          <i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>
        </p>
      
      <p>
        <span>Copyright &copy; 2024 John Doe.</span>
        <span>Theme by <a href="https://github.com/chaooo/hexo-theme-BlueLake/" target="_blank">BlueLake.</a></span>
        <span>Powered by <a href="https://hexo.io/" target="_blank">Hexo.</a></span>
      </p>
    </div>
  </div>
</footer>

    </div>
  </div>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/search.json.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>






  
<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  
    
<script src="/localshare/js/social-share.js"></script>

    
<script src="/localshare/js/qrcode.js"></script>

  
  



  

  

  
    
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

    <script>
      var GUEST_INFO = ['nick','mail','link'];
      var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
      });
      var notify = 'false' == true;
      var verify = 'false' == true;
      new Valine({
          el: '.vcomment',
          notify: notify,
          verify: verify,
          appId: "vLPzzKBu42xSePsXQ9SMFMnu-gzGzoHsz",
          appKey: "SXT5mro1fOk42Qd9iF4lqApa",
          placeholder: "Just go go",
          pageSize:'10',
          avatar:'mm',
          lang:'zh-cn'
      });
    </script>
  

  

  

  

  

  
  





</body>
</html>